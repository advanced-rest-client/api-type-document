<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-if.html">
<link rel="import" href="../polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../raml-aware/raml-aware.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../amf-helper-mixin/amf-helper-mixin.html">
<link rel="import" href="property-shape-document.html">
<link rel="import" href="property-document-mixin.html">
<dom-module id="api-type-document">
  <template>
    <style>
    :host {
      display: block;
      @apply --api-type-document;
    }

    .union-toggle {
      outline: none;
      background-color: var(--api-type-document-union-button-background-color, #fff);
      color: var(--api-type-document-union-button-color, #000);
    }

    .union-toggle[active] {
      background-color: var(--api-type-document-union-button-active-background-color, #CDDC39);
      color: var(--api-type-document-union-button-active-color, #000);
    }

    .union-type-selector {
      margin: 12px 0;
    }

    property-shape-document {
      padding: 12px 0;
    }

    property-shape-document:last-of-type,
    :last-of-type {
      border-bottom: none;
    }
    </style>
    <template is="dom-if" if="[[aware]]">
      <raml-aware raml="{{amfModel}}" scope="[[aware]]"></raml-aware>
    </template>
    <template is="dom-if" if="[[isObject]]" restamp>
      <template is="dom-repeat" data-object-repeater items="[[_computeProperties(_resolvedType)]]">
        <property-shape-document class="object-document" shape="[[_resolve(item)]]" amf-model="[[amfModel]]" parent-type-name="[[parentTypeName]]" narrow="[[narrow]]"></property-shape-document>
      </template>
    </template>
    <template is="dom-if" if="[[isArray]]" restamp>
      <template is="dom-repeat" data-array-repeater items="[[_computeArrayProperties(_resolvedType)]]">
        <template is="dom-if" if="[[item.isShape]]" restamp="true">
          <property-shape-document class="array-document" amf-model="[[amfModel]]" shape="[[_resolve(item)]]" parent-type-name="[[_computeArrayParentName(parentTypeName, item)]]" narrow="[[narrow]]"></property-shape-document>
        </template>
        <template is="dom-if" if="[[item.isType]]" restamp="true">
          <api-type-document class="union-document" amf-model="[[amfModel]]" parent-type-name="[[parentTypeName]]" type="[[item]]" narrow="[[narrow]]"></api-type-document>
        </template>
      </template>
    </template>
    <template is="dom-if" if="[[isScalar]]" restamp>
      <property-shape-document class="shape-document" amf-model="[[amfModel]]" shape="[[_resolvedType]]" parent-type-name="[[parentTypeName]]" narrow="[[narrow]]"></property-shape-document>
    </template>
    <template is="dom-if" if="[[isUnion]]">
      <div class="union-type-selector">
        <span>Any of:</span>
        <template is="dom-repeat" data-union-repeater items="[[unionTypes]]">
          <paper-button class="union-toggle" active="[[_unionTypeActive(selectedUnion, index)]]" on-click="_selectUnion" title$="Select [[item.label]] type">[[item.label]]</paper-button>
        </template>
      </div>
      <api-type-document class="union-document" amf-model="[[amfModel]]" parent-type-name="[[parentTypeName]]" type="[[_computeUnionProperty(_resolvedType, selectedUnion)]]" narrow="[[narrow]]"></api-type-document>
    </template>
  </template>
  <script>
  /**
   * `api-type-document`
   *
   * An element that recuresively renders a documentation for a data type
   * using from model.
   *
   * Pass AMF's shape type `property` array to render the documentation.
   *
   * ## Styling
   *
   * `<api-type-document>` provides the following custom properties and mixins for styling:
   *
   * Custom property | Description | Default
   * ----------------|-------------|----------
   * `--api-type-document` | Mixin applied to this elment | `{}`
   * `--api-type-document-union-button-background-color` | Background color of union selector button | `#fff`
   * `--api-type-document-union-button-color` | Color of union selector button | `#000`
   * `--api-type-document-union-button-active-background-color` | Background color of active union selector button | `#CDDC39`
   * `--api-type-document-union-button-active-color` | Color of active union selector button | `#000`
   *
   * From `property-shape-document`
   *
   * Custom property | Description | Default
   * ----------------|-------------|----------
   * `--property-shape-document` | Mixin applied each proeprty element | `{}`
   * `--property-shape-document-array-color` | Property border color when type is an array | `#8BC34A`
   * `--property-shape-document-object-color` | Property border color when type is an object | `#FF9800`
   * `--property-shape-document-union-color` | Property border color when type is an union | `#FFEB3B`
   * `--arc-font-subhead` | Theme mixin, applied to the property title | `{}`
   * `--property-shape-document-title` | Mixin applied to the property title | `{}`
   * `--api-type-document-property-parent-color` | Color of the parent property label | `#757575`
   * `--api-type-document-property-color` | Color of the property name label when display name is used | `#757575`
   * `--api-type-document-child-docs-margin-left` | Margin left of the item's properties description relative to the title when the item is a child property of another property | `24px`
   * `--api-type-document-type-color` | Color of the "type" trait | `white`
   * `--api-type-document-type-background-color` | Background color of the "type" trait | `#2196F3`
   * `--api-type-document-trait-background-color` | Background color to main range trait (type, required, enum) | `#EEEEEE`,
   * `--api-type-document-trait-border-radius` | Border radious of a main property traits like type, required, enum | `3px`
   *
   * From `property-range-document`
   *
   * Custom property | Description | Default
   * ----------------|-------------|----------
   * `--property-range-document` | Mixin applied to this elment | `{}`
   * `--api-type-document-type-attribute-color` | Color of each attribute that describes a property | `#616161`
   * `--api-type-document-examples-title-color` | Color of examples section title | ``
   * `--api-type-document-examples-border-color` | Example section border color | `transparent`
   * `--code-background-color` | Background color of the examples section | ``
   * `--arc-font-body1` | Mixin applied to an example name label | `{}`
   * `--arc-font-body2` | Mixin applied to the examples section title | `{}`
   *
   * @customElement
   * @polymer
   * @demo demo/index.html
   * @memberof ApiElements
   * @appliesMixin ArcBehaviors.PropertyDocumentMixin
   * @appliesMixin ApiElements.AmfHelperMixin
   */
  class ApiTypeDocument extends
    ApiElements.AmfHelperMixin(ArcBehaviors.PropertyDocumentMixin(Polymer.Element)) {
    static get is() {return 'api-type-document';}
    static get properties() {
      return {
        /**
         * `raml-aware` scope property to use.
         */
        aware: String,
        /**
         * Generated AMF json/ld model form the API spec.
         * The element assumes the object of the first array item to be a
         * type of `"http://raml.org/vocabularies/document#Document`
         * on AMF vocabulary.
         *
         * It is only usefult for the element to resolve references.
         *
         * @type {Object|Array}
         */
        amfModel: Object,
        /**
         * A type definition to render.
         * This should be a one of the following AMF types:
         *
         * - `http://www.w3.org/ns/shacl#NodeShape` (Object)
         * - `http://raml.org/vocabularies/shapes#UnionShape` (Union)
         * - `http://raml.org/vocabularies/shapes#ArrayShape` (Array)
         * - `http://raml.org/vocabularies/shapes#ScalarShape` (single property)
         *
         * It also accepts array of properties like list of headers or
         * parameters.
         * @type {Object|Array}
         */
        type: Object,
        // The type after it has been resolved.
        _resolvedType: {
          type: Object,
          observer: '_typeChanged',
          computed: '_resolve(type)'
        },
        /**
         * Should be set if described properties has a parent type.
         * This is used when recursively iterating over properties.
         */
        parentTypeName: String,
        /**
         * True if given `type` is a scalar property
         */
        isScalar: {
          type: Boolean,
          readOnly: true
        },
        /**
         * True if given `type` is an array property
         */
        isArray: {
          type: Boolean,
          readOnly: true
        },
        /**
         * True if given `type` is an object property
         */
        isObject: {
          type: Boolean,
          readOnly: true
        },
        /**
         * True if given `type` is an union property
         */
        isUnion: {
          type: Boolean,
          readOnly: true
        },
        /**
         * Computed list of union type types to render in union type
         * selector.
         * Each item has `label` and `isScalar` property.
         *
         * @type {Array<Object>}
         */
        unionTypes: {
          type: Array,
          observer: '_unionTypesChanged'
        },
        /**
         * Selected index of union type in `unionTypes` array.
         */
        selectedUnion: {
          type: Number
        },
        /**
         * A property to set when the component is rendered in the narrow
         * view. To be used with mobile rendering or when the
         * components occupies only small part of the screen.
         */
        narrow: Boolean
      };
    }
    /**
     * Handles type change. Sets basic view control properties.
     *
     * @param {Array|Object} type Passed type/
     */
    _typeChanged(type) {
      if (!type) {
        return;
      }
      let isScalar = false;
      let isArray = false;
      let isObject = false;
      let isUnion = false;
      if (type instanceof Array) {
        isObject = true;
      } else if (this._hasType(type, this.ns.raml.vocabularies.shapes + 'ScalarShape') ||
        this._hasType(type, this.ns.raml.vocabularies.shapes + 'NilShape')) {
        isScalar = true;
      } else if (this._hasType(type, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
        isUnion = true;
        this.unionTypes = this._computeUnionTypes(true, type);
      } else if (this._hasType(type, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
        isArray = true;
      } else if (this._hasType(type, this.ns.w3.shacl.name + 'NodeShape')) {
        isObject = true;
      }
      this._setIsScalar(isScalar);
      this._setIsArray(isArray);
      this._setIsObject(isObject);
      this._setIsUnion(isUnion);
    }
    /**
     * Computes parent name for the array type table.
     *
     * @param {?String} parent `parentTypeName` if available
     * @return {String} Parent type name of refault value for array type.
     */
    _computeArrayParentName(parent) {
      return parent || '';
    }
    /**
     * Resets union selection when union types list changes.
     *
     * @param {?Array} types List of current union types.
     */
    _unionTypesChanged(types) {
      if (!types) {
        return;
      }
      this.selectedUnion = 0;
    }
    /**
     * Handler for union type button click.
     * Sets `selectedUnion` property.
     *
     * @param {ClickEvent} e
     */
    _selectUnion(e) {
      const index = e.model.get('index');
      if (this.selectedUnion === index) {
        e.target.active = true;
      } else {
        this.selectedUnion = index;
      }
    }
    /**
     * Computes if selectedUnion equals current item index.
     *
     * @param {Number} selectedUnion
     * @param {Number} index
     * @return {Boolean}
     */
    _unionTypeActive(selectedUnion, index) {
      return selectedUnion === index;
    }
    /**
     * Computes properties for union type.
     *
     * @param {Object} type Current `type` value.
     * @param {Number} selected Selected union index from `unionTypes` array
     * @return {Array<Object>|undefined} Properties for union type.
     */
    _computeUnionProperty(type, selected) {
      if (!type) {
        return;
      }
      const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
      const data = type[key];
      if (!data) {
        return;
      }
      const item = data[selected];
      if (!item) {
        return;
      }
      if (this._hasType(item, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
        const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
        const items = this._ensureArray(item[key]);
        if (items && items.length === 1) {
          return this._resolve(items[0]);
        }
      }
      return this._resolve(item);
    }
    /**
     * Helper function for the view. Extracts `http://www.w3.org/ns/shacl#property`
     * from the shape model
     *
     * @param {Object} item Range object
     * @return {Array<Object>} Shape object
     */
    _computeProperties(item) {
      if (item instanceof Array) {
        return item;
      }
      if (!item) {
        return;
      }
      const key = this._getAmfKey(this.ns.w3.shacl.name + 'property');
      return this._ensureArray(item[key]);
    }
  }
  window.customElements.define(ApiTypeDocument.is, ApiTypeDocument);
  </script>
</dom-module>
