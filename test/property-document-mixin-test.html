<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-type-document test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <script type="module" src="./test-document-mixin.js"></script>
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <test-document-mixin></test-document-mixin>
    </template>
  </test-fixture>

  <script type="module">
  import {AmfLoader} from './amf-loader.js';
  suite('property-document-mixin', () => {
    suite('_computeRangeDataType()', () => {
      [
        ['Regulat model', false],
        ['Compact model', true]
      ].forEach((item) => {
        suite(item[0], () => {
          let element;
          let model;
          suiteSetup(() => {
            return AmfLoader.loadType('ScalarType', item[1])
            .then((data) => {
              model = data[0];
            });
          });

          setup(() => {
            element = fixture('Basic');
            element.amfModel = model;
          });

          test('Computes UnionShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#UnionShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Union');
          });

          test('Computes ArrayShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#ArrayShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Array');
          });

          test('Computes NodeShape', () => {
            const type = element._getAmfKey('http://www.w3.org/ns/shacl#NodeShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Object');
          });

          test('Computes FileShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#FileShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'File');
          });

          test('Computes NilShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#NilShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Null');
          });

          test('Computes AnyShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#AnyShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Any');
          });

          test('Computes MatrixShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#MatrixShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Matrix');
          });

          test('Computes TupleShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#TupleShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Tuple');
          });

          test('Computes RecursiveShape', () => {
            const type = element._getAmfKey('http://a.ml/vocabularies/shapes#RecursiveShape');
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Recursive');
          });

          test('Computes Unknown type', () => {
            const type = 'unknown';
            const result = element._computeRangeDataType({
              '@type': [type]
            });
            assert.equal(result, 'Unknown type');
          });

          test('Returns undefined when no argument', () => {
            const result = element._computeRangeDataType();
            assert.isUndefined(result);
          });
        });
      });
    });

    suite('_computeRangeDataType() - ScalarShape', () => {
      let element;
      let shape = {
        '@type': ['http://a.ml/vocabularies/shapes#ScalarShape'],
        'http://www.w3.org/ns/shacl#datatype': [{
          '@id': ''
        }]
      };
      suiteSetup(() => {
        element = fixture('Basic');
      });

      function setType(type) {
        shape['http://www.w3.org/ns/shacl#datatype'][0]['@id'] = type;
      }

      [
        ['http://a.ml/vocabularies/shapes#number', 'Number'],
        ['http://www.w3.org/2001/XMLSchema#integer', 'Integer'],
        ['http://www.w3.org/2001/XMLSchema#string', 'String'],
        ['http://www.w3.org/2001/XMLSchema#boolean', 'Boolean'],
        ['http://www.w3.org/2001/XMLSchema#date', 'Date'],
        ['http://www.w3.org/2001/XMLSchema#time', 'Time'],
        ['http://www.w3.org/2001/XMLSchema#dateTime', 'DateTime'],
        ['http://a.ml/vocabularies/shapes#dateTimeOnly', 'Time'],
        ['http://www.w3.org/2001/XMLSchema#float', 'Float'],
        ['http://www.w3.org/2001/XMLSchema#long', 'Long'],
        ['http://www.w3.org/2001/XMLSchema#double', 'Double'],
        ['http://www.w3.org/2001/XMLSchema#base64Binary', 'Base64 binary'],
        ['http://a.ml/vocabularies/shapes#password', 'Password'],
        ['UNKNOWN', 'Unknown type']
      ].forEach((item) => {
        test('Computes ' + item[0], () => {
          setType(item[0]);
          const result = element._computeRangeDataType(shape);
          assert.equal(result, item[1]);
        });
      });
    });

    suite('_computeRangeDataType() - ScalarShape - compact model', () => {
      let element;
      const shape = {
        '@type': ['raml-shapes:ScalarShape'],
        'shacl:datatype': [{
          '@id': ''
        }]
      };

      suiteSetup(() => {
        return AmfLoader.load(true)
        .then((model) => {
          element = fixture('Basic');
          element.amfModel = model;
        });
      });

      function setType(type) {
        shape['shacl:datatype'][0]['@id'] = type;
      }

      [
        ['http://a.ml/vocabularies/shapes#number', 'Number'],
        ['http://www.w3.org/2001/XMLSchema#integer', 'Integer'],
        ['http://www.w3.org/2001/XMLSchema#string', 'String'],
        ['http://www.w3.org/2001/XMLSchema#boolean', 'Boolean'],
        ['http://www.w3.org/2001/XMLSchema#date', 'Date'],
        ['http://www.w3.org/2001/XMLSchema#time', 'Time'],
        ['http://www.w3.org/2001/XMLSchema#dateTime', 'DateTime'],
        ['http://a.ml/vocabularies/shapes#dateTimeOnly', 'Time'],
        ['http://www.w3.org/2001/XMLSchema#float', 'Float'],
        ['http://www.w3.org/2001/XMLSchema#long', 'Long'],
        ['http://www.w3.org/2001/XMLSchema#double', 'Double'],
        ['http://www.w3.org/2001/XMLSchema#base64Binary', 'Base64 binary'],
        ['http://a.ml/vocabularies/shapes#password', 'Password'],
        ['UNKNOWN', 'Unknown type']
      ].forEach((item) => {
        test('Computes ' + item[0], () => {
          setType(item[0]);
          const result = element._computeRangeDataType(shape);
          assert.equal(result, item[1]);
        });
      });
    });

    suite('_computeRange()', () => {
      let element;
      const ScalarShape = {
        '@type': ['http://a.ml/vocabularies/shapes#ScalarShape'],
        'http://www.w3.org/ns/shacl#datatype': [{
          '@id': 'http://a.ml/vocabularies/shapes#number'
        }]
      };
      const ParameterShape = {
        '@type': ['http://a.ml/vocabularies/http#Parameter'],
        'http://a.ml/vocabularies/http#schema': ['TEST-PARAMETER']
      };
      const NodeShape = {
        '@type': ['http://a.ml/vocabularies/http#NodeShape'],
        'http://a.ml/vocabularies/shapes#range': ['TEST-RANGE']
      };
      suiteSetup(() => {
        element = fixture('Basic');
      });

      test('Computes range for scalar shape', () => {
        const result = element._computeRange(ScalarShape);
        assert.isTrue(result === ScalarShape);
      });

      test('Computes range for parameter shape', () => {
        const result = element._computeRange(ParameterShape);
        assert.equal(result, 'TEST-PARAMETER');
      });

      test('Computes range for node shape', () => {
        const result = element._computeRange(NodeShape);
        assert.equal(result, 'TEST-RANGE');
      });
    });
  });

  suite('_computeArrayProperties()', () => {
    [
      ['Regulat model', false],
      ['Compact model', true]
    ].forEach((item) => {
      suite(item[0], () => {
        let element;
        let model;
        suiteSetup(() => {
          return AmfLoader.loadType('ScalarType', item[1])
          .then((data) => {
            model = data[0];
          });
        });

        setup(() => {
          element = fixture('Basic');
          element.amfModel = model;
        });

        test('Returnms undefined when no argument', () => {
          const result = element._computeArrayProperties();
          assert.isUndefined(result);
        });

        test('Returnms undefined when no "items" in shape', () => {
          const result = element._computeArrayProperties({});
          assert.isUndefined(result);
        });

        test('Returnms undefined when "items" is empty array', () => {
          const iKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'items');
          const model = {};
          model[iKey] = [];
          const result = element._computeArrayProperties(model);
          assert.isUndefined(result);
        });

        test('Handles scalar shape', () => {
          const iKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'items');
          const sKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'ScalarShape');
          const model = {};
          const item = {
            '@type': [sKey]
          };
          model[iKey] = [item];
          const result = element._computeArrayProperties(model);
          assert.typeOf(result, 'array');
          assert.lengthOf(result, 1);
          assert.isTrue(result[0].isShape);
        });

        test('Handles UnionShape shape', () => {
          const iKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'items');
          const sKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'UnionShape');
          const model = {};
          const item = {
            '@type': [sKey]
          };
          model[iKey] = [item];
          const result = element._computeArrayProperties(model);
          assert.typeOf(result, 'array');
          assert.lengthOf(result, 1);
          assert.isTrue(result[0].isType);
        });

        test('Handles ArrayShape shape', () => {
          const iKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'items');
          const sKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'ArrayShape');
          const model = {};
          const item = {
            '@type': [sKey]
          };
          model[iKey] = [item];
          const result = element._computeArrayProperties(model);
          assert.typeOf(result, 'array');
          assert.lengthOf(result, 1);
          assert.isTrue(result[0].isType);
        });

        test('Handles NodeShape shape', () => {
          const iKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'items');
          const sKey = element._getAmfKey(element.ns.raml.vocabularies.shapes + 'NodeShape');
          const pKey = element._getAmfKey(element.ns.w3.shacl.name + 'property');
          const model = {};
          const item = {
            '@type': [sKey]
          };
          const properties = [{}];
          item[pKey] = properties;
          model[iKey] = [item];
          const result = element._computeArrayProperties(model);
          assert.typeOf(result, 'array');
          assert.lengthOf(result, 1);
          assert.isTrue(result[0].isShape);
        });
      });
    });
  });
  </script>
</body>
</html>
