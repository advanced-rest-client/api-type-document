<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/lib/utils/mixin.html">
<script>
(function(global) {
'use strict';
if (!global.ArcBehaviors) {
  /**
   * @namespace ArcBehaviors
   */
  global.ArcBehaviors = {};
}
/**
 * A mixin that contains common function for `property-*-document` elements.
 *
 * @polymer
 * @mixinFunction
 * @memberof ArcBehaviors
 */
ArcBehaviors.PropertyDocumentMixin = Polymer.dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class PDmixin extends base {
    static get properties() {
      return {
        /**
         * Generated AMF json/ld model form the API spec.
         * The element assumes the object of the first array item to be a
         * type of `"http://raml.org/vocabularies/document#Document`
         * on AMF vocabulary.
         *
         * It is only usefult for the element to resolve references.
         *
         * @type {Object|Array}
         */
        amfModel: Object,
        /**
         * A property shape definition of AMF.
         *
         * @type {Object}
         */
        shape: Object,
        /**
         * Computes value of shape's http://raml.org/vocabularies/shapes#range
         * @type {Object}
         */
        range: Object
      };
    }

    /**
     * Computes type from a `http://raml.org/vocabularies/shapes#range` object
     *
     * @param {Object} range AMF property range object
     * @return {String} Data type of the property.
     */
    _computeRangeDataType(range) {
      if (!range) {
        return;
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#UnionShape')) {
        return 'Union';
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#ArrayShape')) {
        return 'Array';
      }
      if (this._hasType(range, 'http://www.w3.org/ns/shacl#NodeShape')) {
        return 'Object';
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#FileShape')) {
        return 'File';
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#NilShape')) {
        return 'Null';
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#AnyShape')) {
        return 'Any';
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#MatrixShape')) {
        return 'Matrix';
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#TupleShape')) {
        return 'Tuple';
      }
      if (this._hasType(range, 'http://raml.org/vocabularies/shapes#ScalarShape')) {
        switch (range['http://www.w3.org/ns/shacl#datatype'][0]['@id']) {
          case 'http://www.w3.org/2001/XMLSchema#string': return 'String';
          case 'http://www.w3.org/2001/XMLSchema#integer': return 'Integer';
          case 'http://www.w3.org/2001/XMLSchema#long': return 'Long';
          case 'http://www.w3.org/2001/XMLSchema#float': return 'Float';
          case 'http://www.w3.org/2001/XMLSchema#double': return 'Double';
          case 'http://raml.org/vocabularies/shapes#number': return 'Number';
          case 'http://www.w3.org/2001/XMLSchema#boolean': return 'Boolean';
          case 'http://www.w3.org/2001/XMLSchema#dateTime': return 'DateTime';
          case 'http://raml.org/vocabularies/shapes#dateTimeOnly': return 'Time';
          case 'http://www.w3.org/2001/XMLSchema#time': return 'Time';
          case 'http://www.w3.org/2001/XMLSchema#date': return 'Date';
          case 'http://www.w3.org/2001/XMLSchema#base64Binary': return 'Base64 binary';
          case 'http://raml.org/vocabularies/shapes#password': return 'Password';
        }
      }
      return 'Unknown type';
    }
    /**
     * Computes value for `range` property.
     * @param {Object} shape Current shape object.
     * @return {Object} Range object
     */
    _computeRange(shape) {
      if (!shape) {
        return;
      }
      let data;
      if (this._hasType(shape, 'http://raml.org/vocabularies/shapes#ScalarShape')) {
        data = shape;
      } else if (this._hasType(shape, 'http://raml.org/vocabularies/http#Parameter')) {
        data = shape['http://raml.org/vocabularies/http#schema'];
        data = (data && data.length) ? data[0] : undefined;
      } else {
        data = shape['http://raml.org/vocabularies/shapes#range'];
        data = (data && data.length) ? data[0] : undefined;
      }
      return data;
    }
    /**
     * Helper function for the view. Extracts `http://www.w3.org/ns/shacl#property`
     * from the shape model
     *
     * @param {Object} item Range object
     * @return {Object} Shape object
     */
    _computeProperties(item) {
      if (item instanceof Array) {
        return item;
      }
      return item && item['http://www.w3.org/ns/shacl#property'];
    }
    /**
     * Computes properties to render Array items documentation.
     *
     * @param {Object} range Range object of current shape.
     * @return {Array<Object>|undefined} List of Array items.
     */
    _computeArrayProperties(range) {
      if (!range) {
        return;
      }
      let items = range['http://raml.org/vocabularies/shapes#items'];
      if (!items) {
        return;
      }
      items = items[0];
      return items['http://www.w3.org/ns/shacl#property'];
    }
    /**
     * Computes value for `isUnion` property.
     * Union type is identified as a `http://raml.org/vocabularies/shapes#UnionShape`
     * type.
     *
     * @param {Object} range Range object of current shape.
     * @return {Boolean}
     */
    _computeIsUnion(range) {
      return this._hasType(range, 'http://raml.org/vocabularies/shapes#UnionShape');
    }
    /**
     * Computes value for `isObject` property.
     * Object type is identified as a `http://raml.org/vocabularies/shapes#NodeShape`
     * type.
     *
     * @param {Object} range Range object of current shape.
     * @return {Boolean}
     */
    _computeIsObject(range) {
      return this._hasType(range, 'http://www.w3.org/ns/shacl#NodeShape');
    }
    /**
     * Computes value for `isArray` property.
     * Array type is identified as a `http://raml.org/vocabularies/shapes#ArrayShape`
     * type.
     *
     * @param {Object} range Range object of current shape.
     * @return {Boolean}
     */
    _computeIsArray(range) {
      return this._hasType(range, 'http://raml.org/vocabularies/shapes#ArrayShape');
    }
    /**
     * Computes list of union type labels to render.
     *
     * @param {Boolean} isUnion
     * @param {Object} range
     * @return {Array<Object>}
     */
    _computeUnionTypes(isUnion, range) {
      if (!isUnion || !range) {
        return;
      }
      const list = range['http://raml.org/vocabularies/shapes#anyOf'];
      if (!list) {
        return;
      }
      return list.map((item) => {
        let isScalar = this._hasType(item, 'http://raml.org/vocabularies/shapes#ScalarShape');
        const isNil = this._hasType(item, 'http://raml.org/vocabularies/shapes#NilShape');
        if (!isScalar && isNil) {
          isScalar = true;
        }
        let isArray = this._hasType(item, 'http://raml.org/vocabularies/shapes#ArrayShape');
        let isType = !isScalar && !isArray;
        let label;
        if (isArray) {
          label = this._computeArrayUnionLabel(item['http://raml.org/vocabularies/shapes#items']);
        } else if (isNil) {
          label = 'Null';
        } else {
          label = this._getValue(item, 'http://schema.org/name');
          if (!label) {
            label = this._getValue(item, 'http://www.w3.org/ns/shacl#name');
          }
          if (!label && this._hasType(item, 'http://raml.org/vocabularies/shapes#ScalarShape')) {
            label = this._computeRangeDataType(item);
          }
        }
        if (!label) {
          label = 'Unnamed type';
        }
        return {
          isScalar,
          isArray,
          isType,
          label
        };
      });
    }
    /**
     * Computes union type label when the union is in Array.
     *
     * @param {Array} items Array items property
     * @return {String|undefined} Label for the union type.
     */
    _computeArrayUnionLabel(items) {
      if (!items || !(items instanceof Array)) {
        return;
      }
      const item = items[0];
      if (this._hasType(item, 'http://raml.org/vocabularies/shapes#ScalarShape')) {
        return this._computeRangeDataType(item);
      }
      return this._computeDisplayName(item);
    }

    /**
     * Computes name label for the shape.
     *
     * @param {Object} range Range object of current shape.
     * @param {Object} shape The shape of the property.
     * @return {String} Display name of the property
     */
    _computeDisplayName(range, shape) {
      if (!shape || !range) {
        return;
      }
      let name;
      if (this._hasType(shape, 'http://raml.org/vocabularies/http#Parameter')) {
        name =  this._getValue(range, 'http://schema.org/name');
        if(!name) {
          name =  this._getValue(shape, 'http://raml.org/vocabularies/http#paramName');
        }
      } else if (this._hasType(range, 'http://www.w3.org/ns/shacl#NodeShape')) {
        name = this._getValue(shape, 'http://www.w3.org/ns/shacl#name');
      } else {
        name = this._getValue(range, 'http://schema.org/name');
        if (!name) {
          name = this._getValue(range, 'http://www.w3.org/ns/shacl#name');
        }
      }
      if (!name) {
        // File and Union types does not have "name" on range object.
        name = this._getValue(shape, 'http://www.w3.org/ns/shacl#name');
      }
      if (name && name[name.length - 1] === '?') {
        name = name.substr(0, name.length - 1);
      }
      return name;
    }
  }
return PDmixin;
});
})(window);
</script>
